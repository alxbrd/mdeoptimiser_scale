//package uk.ac.kcl.inf.mdeoptimiser.infrastructure.scale.messaging;
//
//import uk.ac.kcl.inf.mdeoptimiser.infrastructure.scale.interpreter.experiments.ExperimentConfiguration;
//import uk.ac.kcl.inf.mdeoptimiser.infrastructure.scale.interpreter.experiments.tasks.TaskType;
//import uk.ac.kcl.inf.mdeoptimiser.infrastructure.scale.jobs.IScaleJob;
//
//import java.io.File;
//import java.util.HashMap;
//import java.util.Map;
//import java.util.Set;
//
//public class TaskPayload {
//
//  public TaskPayload(ScaleJob job, ExperimentConfiguration experimentConfiguration){
//
//    this.experimentInstanceNamePrefix = job.getTask().getExperimentInstanceNamePrefix();
//    this.experimentModelNamePrefix = job.getTask().getExperimentModelNamePrefix();
//    this.setArtifactsLocation(experimentConfiguration.getEperimentArtifacts().keySet());
//    this.setDependenciesLocation(job.getTask().getDependencies().keySet());
//    this.setSpecLocation(job.getTask().getCommand());
//    this.setBatchNumber(job.getBatchNumber());
//    this.setUploadLocation(experimentConfiguration.getUploadLocation());
//    this.setTaskType(job.getTask().getType());
//  }
//
//  /**
//   * Experiment instance name prefix. The root path where the experiment files are
//   * stored on S3.
//   */
//  private String experimentInstanceNamePrefix;
//
//  /**
//   * Experiment model name prefix. The path below the root path where the experiment files
//   * for this job are stored on s3.
//   */
//  private String experimentModelNamePrefix;
//
//  /**
//   * This includes the list of experiment artifacts for a specific problem.
//   */
//  private Map<String, String> artifactsLocation;
//
//  /**
//   * The path from where to fetch the required classpath dependencies for the fitness
//   * functions.
//   */
//  private Map<String, String> dependenciesLocation;
//
//  /**
//   * The location of the configured spec for this job
//   */
//  private String specLocation;
//
//  /**
//   * The number of the current batch for this job
//   */
//  private int batchNumber;
//
//  /**
//   * The output path for the results files generated by the current job
//   */
//  private String uploadLocation;
//
//  /**
//   * The task type configured for this job
//   */
//  private TaskType taskType;
//
//  public Map<String, String> getArtifactsLocation() {
//    return artifactsLocation;
//  }
//
//  public void setArtifactsLocation(Set<String> artifactsLocation) {
//
//    var locations = new HashMap<String, String>();
//
//    artifactsLocation.forEach(key -> {
//      //TODO This currently maps the key to itself. Do we want a better file structure inside the container?
//      //Should we use removePrefix on the value here?
//      locations.put(key, removePrefix(key));
//    });
//
//    this.artifactsLocation = locations;
//  }
//
//  public Map<String, String> getDependenciesLocation() {
//
//    return dependenciesLocation;
//  }
//
//  public void setDependenciesLocation(Set<String> dependenciesLocation) {
//
//    var dependenciesLocations = new HashMap<String, String>();
//
//    dependenciesLocation.forEach(key -> {
//
//      //TODO This currently maps the key to itself. Do we want a better file structure inside the container?
//      dependenciesLocations.put(key, removePrefix(key));
//    });
//
//    this.dependenciesLocation = dependenciesLocations;
//  }
//
//  public String getSpecLocation() {
//    return specLocation;
//  }
//
//  public void setSpecLocation(String specLocation) {
//    this.specLocation = specLocation;
//  }
//
//  public int getBatchNumber() {
//    return batchNumber;
//  }
//
//  public void setBatchNumber(int batchNumber) {
//    this.batchNumber = batchNumber;
//  }
//
//  public String getUploadLocation() {
//    return uploadLocation;
//  }
//
//  public void setUploadLocation(String uploadLocation){
//    this.uploadLocation = uploadLocation;
//  }
//
//  public void setTaskType(TaskType taskType) {
//    this.taskType = taskType;
//  }
//
//  public TaskType getTasktype(){
//    return this.taskType;
//  }
//
//  /**
//   * Remove the S3 prefix from the configured S3 path. This gives nice clean paths to the tool wrapper executor.
//   * @param key
//   * @return
//   */
//  private String removePrefix(String key) {
//
//    //Remove experiment instance name prefix
//    key = new File(this.experimentInstanceNamePrefix).toURI().relativize(new File(key).toURI()).getPath();
//
//    if(key.startsWith(this.experimentModelNamePrefix)) {
//      //Remove the experiment model name prefix if there is one
//      return new File(this.experimentModelNamePrefix).toURI().relativize(new File(key).toURI()).getPath();
//    }
//
//    return key;
//  }
//}